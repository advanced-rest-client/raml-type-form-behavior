<!--
@license
Copyright 2017 The Advanced REST client authors <arc@mulesoft.com>

Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="jsonld-import.html">

<script>
(function(global) {
  'use strict';
  var NUMBER_INPUT_TYPES = ['number', 'integer', 'float'];
  //
  var RAML_V_HTTP = 'http://raml.org/vocabularies/http';
  var RAML_V_SHAPES = 'http://raml.org/vocabularies/shapes';
  var HYDRA_CORE = 'http://www.w3.org/ns/hydra/core';
  var SCHEMA = 'http://schema.org/';
  var SHACL = 'http://www.w3.org/ns/shacl';
  var RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns';
  global.ArcBehaviors = global.ArcBehaviors || {};
  /**
   * A behavior to transform RAML model into a form view model.
   *
   * Note, this model does not include polyfills for `Promise` and `Array.from`.
   *
   * The model should be used to build a form view for request parameters
   * like header, query parameters, uri parameters or the body.
   *
   * ### Data model
   * - binding {String} - one of `path`, `query`, `header`
   * - name {String} - property (form) name
   * - required {Boolean} - is property required
   * - value {any} - Value of the property
   * - description {String} - The description of the property
   * - hasDescription {Boolean} - Flag describing if the property has a
   * description.
   * - schema {Object} - Property schma information
   * - schema.type {String} - Data type of the property
   * - schema.inputLabel {String} Label for the form control
   * - schema.inputType {String} - type attribute of the `input` element.
   * - schema.pattern {String} - Regex pattern of the property
   * - schema.minLength {Number} - String property minimum length
   * - schema.maxLength {Number} - String property maximum length
   * - schema.defaultValue {any} - Default value of the property
   * - schema.examples {Array<Object>} - List of examples for the form property.
   * - schema.multipleOf {Number} - For numeric values, a `step` attribute of
   * the `input` element.
   * Each object may contain `name` (may be undefined) and must contain `value`
   * property of the example.
   * - schema.minimum {Number} - For numeric values, minimum value of the property
   * - schema.maximum {Number} - For numeric values, maximum value of the property
   * - schema.isEnum {Boolean} - Flag describing enumerable value
   * - schema.enum {Array<any>} - Only if `schema.isEnum` is set. Values for enum
   * input.
   * - schema.isArray {Boolean} - Flag describing array value for the property
   * - schema.isBool {Boolean} - Flag describing boolean value for the property
   * - schema.inputPlaceholder {?String} - A placeholder value for the input.
   * - schema.inputFloatLabel {Boolean} - Only if placeholder is set. Instructs
   * input control to float a label.
   * @polymerBehavior ArcBehaviors.RamlTypeFormBehavior
   */
  global.ArcBehaviors.RamlTypeFormBehavior = {
    properties: {
      /**
       * AMF model extracted from RAML or OAS spec and transformed to
       * JSON/LD schema.
       * This is an array of propertues for which view model is generated.
       * It accepts model for headers, query parameters, uri parameters and
       * body.
       * If `manualModel` is not set, assigning a value to this property will
       * trigger model computation. Otherwise call `computeViewModel()`
       * function manually to generate the model.
       */
      amfModel: Array,
      /**
       * Generated by data transformer view model used in ARC elements to build
       * the UI for forms.
       */
      viewModel: {
        type: Array,
        notify: true
      },
      /**
       * If set, assigning a value to `amfModel` will not trigger view model
       * computation.
       */
      manualModel: {
        type: Boolean,
        value: false
      },
      /**
       * AMF json/ld contect to use to find keys in the model.
       *
       * ### Example
       * ```javascript
       * {
       *  "doc": "http://raml.org/vocabularies/document#",
       *  "shapes": "http://raml.org/vocabularies/shapes#",
       *  "raml-http": "http://raml.org/vocabularies/http#"
       *  }
       * ```
       * This context generate the following keys for the `amfModel`:
       * - `doc:Document` as `http://raml.org/vocabularies/document#Document`
       * - `shapes:NilShape` as `http://raml.org/vocabularies/shapes#NilShape`
       * - `raml-http:Parameter` as `http://raml.org/vocabularies/http#Parameter`
       *
       * Context can be used to reduce model size by shortering namespace
       * declaration. Setting `amfContext` allows this element to propertly
       * read the schema.
       */
      amfContext: Object,
      /**
       * For URI / Query parameters models it instructs the translator to
       * decode amf model values before setting the view model value.
       */
      decodeValues: Boolean
    },

    observers: [
      '_amfModelChanged(amfModel, manualModel)'
    ],
    /**
     * Called when either `amfModel` or `manualModel` propeties changed.
     * If `manualModel` is falsy then it calls `computeViewModel()` function.
     *
     * Note, this function won't be called when sub property of the model
     * change. For peformance rerasons it won't be supported.
     *
     * Note, `computeViewModel` is called asynchronusly so `amfContext`
     * property can be set.
     *
     * @param {Array} amfModel Current AMF model
     * @param {Boolean} manualModel Current value of the `manualModel` property.
     */
    _amfModelChanged: function(amfModel, manualModel) {
      if (manualModel !== false) {
        return;
      }
      this.debounce('amf-model-tranform', function() {
        this.computeViewModel(amfModel, this.amfContext);
      }, 1);
    },

    /**
     * Computes view model from AMF data model. This should not be called if
     * `manualModel` is not set. Use `amfModel` property instead.
     *
     * @param {?Array} amfModel AMF type model. If not set it uses `amfModel`
     * property of the element.
     * @param {?Object} amfContext JSON ld schema context. The same as
     * `amfContext` property. Don't set the property on the element when using
     * manual model computation. Instead call this function with context.
     */
    computeViewModel: function(amfModel, amfContext) {
      this.set('viewModel', undefined);
      if (!amfModel || !amfModel.length) {
        return;
      }
      var hasContext = !!amfContext;
      var promise;
      if (hasContext) {
        promise = this._expandSchema(amfModel, amfContext);
      } else {
        promise = Promise.resolve(amfModel);
      }
      return promise
      .then(function(model) {
        return this._computeViewModelRecursive(Array.from(model));
      }.bind(this))
      .then(function(model) {
        this.set('viewModel', model);
      }.bind(this));
    },
    /**
     * Conputes model for each item recursively. It allows browser to return
     * the event loop and prohibit ANR to show.
     *
     * @param {Array} items List of remanding AMF model items.
     * This shuld be copy of the model since this function removes items from
     * the list.
     * @param {?Array} result Result of model comupation. It's repoted by
     * the Promise.
     * @return {Promise} Promise resolved to thre view model.
     */
    _computeViewModelRecursive: function(items, result) {
      result = result || [];
      if (!items || !items.length) {
        return Promise.resolve(result);
      }
      var item = items.shift();
      var model = this.uiModelForAmfItem(item);
      if (model) {
        result.push(model);
      } else {
        console.warn('Unable to compute view data model for', item);
      }
      return Promise.resolve()
      .then(function() {
        return this._computeViewModelRecursive(items, result);
      }.bind(this));
    },
    /**
     * Creates a UI model item from AMF json/ld model.
     * @param {Object} amfItem AMF model with schema for
     * `http://raml.org/vocabularies/http#Parameter`
     * @return {Object} UI data model.
     */
    uiModelForAmfItem: function(amfItem) {
      if (!this._modelHasType(amfItem, 'http://raml.org/vocabularies/http#Parameter')) {
        return;
      }
      var result = {};
      /*- √ binding {String} - one of `path`, `query`, `header`
      * - √ name {String} - property (form) name
      * - √ required {Boolean} - is property required
      * - value {any} - Value of the property
      * - √ description {String} - The description of the property
      * - √ hasDescription {Boolean}
      * - schema {Object} - Property schma information
      */
      result.binding = this._computeBinding(amfItem);
      result.name = this._computeFormName(amfItem);
      result.description = this._computeDescription(amfItem);
      result.hasDescription = !!result.description;
      result.required = this._computeRequired(amfItem);
      result.schema = this._computeFormSchema(amfItem, result);
      return result;
    },
    /**
     * Computes schema property of the view model from AMF model.
     *
     * @param {Object} model AFM json/ld model.
     * @param {Object} opts Options for model generation.
     * - required {Boolean} true if item is required.
     * - name {String} Property name
     * @return {Object} Schema part of the view model
     */
    _computeFormSchema: function(model, opts) {
      opts = opts || {};
      var result = {};
      var key = RAML_V_HTTP + '#schema';
      if (!model[key]) {
        return;
      }
      var def = model[key][0];
      /**
       * - schema.type {String} - Data type of the property
      * - √ schema.inputLabel {String} Label for the form control
      * - schema.inputType {String} - type attribute of the `input` element.
      * - √ schema.pattern {String} - Regex pattern of the property
      * - √ schema.minLength {Number} - String property minimum length
      * - √ schema.maxLength {Number} - String property maximum length
      * - √ schema.defaultValue {any} - Default value of the property
      * - √ schema.minimum
      * - √ schema.maximum
      * - schema.examples {Array<Object>} - List of examples for the form property.
      * - √ schema.multipleOf {Number} -
      * - √ schema.isEnum {Boolean} - Flag describing enumerable value
      * - √ schema.enum {Array<any>} -
      * - √ schema.isArray {Boolean} - Flag describing array value for the property
      * - √ schema.isBool {Boolean} - Flag describing boolean value for the property
      * - schema.inputPlaceholder {?String} - A placeholder value for the input.
      * - schema.inputFloatLabel {Boolean} - Only if placeholder is set. Instructs
      * input control to float a label.*/
      result.type = this._computeModelType(def);
      result.inputLabel = this._computeInputLabel(def, opts.required, opts.name);
      result.pattern = this._computeShaclProperty(def, 'pattern');
      result.minLength = this._computeShaclProperty(def, 'minLength');
      result.maxLength = this._computeShaclProperty(def, 'maxLength');
      result.defaultValue = this._computeShaclProperty(def, 'defaultValue');
      result.multipleOf = this._computeVocabularyShapeProperty(def, 'multipleOf');
      result.minimum = this._computeShaclProperty(def, 'minInclusive');
      result.maximum = this._computeShaclProperty(def, 'maxInclusive');
      result.enum = this._computeModelEnum(def);
      result.isEnum = !!result.enum;
      result.isArray = result.type === 'array';
      result.isBool = result.type === 'boolean';
      return result;
    },
    /**
     * Uses the json-ld library to expand context properties.
     * @param {Object} compacted Compacted form of the schema.
     * @return {Promise} Resolved promise to a restored object
     */
    _expandSchema: function(model, context) {
      var data = {
        '@context': context,
        amfModelData: model
      };
      /* global jsonld, Promise */
      return new Promise(function(resolve, reject) {
        jsonld.expand(data, function(err, expanded) {
          if (err) {
            reject(err);
          } else {
            resolve(expanded.amfModelData);
          }
        });
      });
    },
    /**
     * Checks if a model has a type.
     * @param {Object} model Model to test
     * @param {String} type Type name
     * @return {Boolean} True if model has a type.
     */
    _modelHasType: function(model, type) {
      var types = model['@type'] || [];
      for (var i = 0; i < types.length; i++) {
        if (types[i] === type) {
          return true;
        }
      }
      return false;
    },
    /**
     * Computes value of the `binding` property of the UI model.
     * @param {Object} model AMF item model
     * @return {String|undefined} Binding property or undefined if not found.
     */
    _computeBinding: function(model) {
      var key = RAML_V_HTTP + '#binding';
      if (!model[key]) {
        return;
      }
      return model[key][0]['@value'];
    },
    /**
     * Computes fomm (parameter) name from AMF model.
     * @param {Object} model AMF item model
     * @return {String|undefined} Name property or undefined if not found.
     */
    _computeFormName: function(model) {
      var key = SCHEMA + 'name';
      if (!model[key]) {
        return;
      }
      return model[key][0]['@value'];
    },
    /**
     * Computes description from AMF model.
     * @param {Object} model AMF item model
     * @return {String|undefined} Description property or undefined if not found.
     */
    _computeDescription: function(model) {
      var key = SCHEMA + 'description';
      if (!model[key]) {
        return;
      }
      return model[key][0]['@value'];
    },
    /**
     * Computes rwquired property from AMF model.
     * @param {Object} model AMF item model
     * @return {Boolean} True if the property is required.
     */
    _computeRequired: function(model) {
      var key = HYDRA_CORE + '#required';
      if (!model[key]) {
        return;
      }
      return model[key][0]['@value'];
    },
    /**
     * Computes type of the model. It's RAML data type property.
     * @param {Object} model Property schema.
     * @return {String} Type of the nproperty.
     */
    _computeModelType: function(model) {
      if (this._modelHasType(model, RAML_V_SHAPES + '#UnionShape')) {
        return 'union';
      }
      if (this._modelHasType(model, RAML_V_SHAPES + '#ArrayShape')) {
        return 'array';
      }

      if (this._modelHasType(model, SHACL + '#ScalarShape')) {
        switch (model[SHACL + '#datatype'][0]['@id']) {
          case 'http://www.w3.org/2001/XMLSchema#integer': return 'integer';
          case 'http://www.w3.org/2001/XMLSchema#string': return 'string';
          case 'http://www.w3.org/2001/XMLSchema#boolean': return 'boolean';
          case 'http://www.w3.org/2001/XMLSchema#date': return 'date';
          case 'http://www.w3.org/2001/XMLSchema#time': return 'time';
          case 'http://www.w3.org/2001/XMLSchema#dateTime': return 'dateTime';
          case 'http://www.w3.org/2001/XMLSchema#dateTime': return 'float';
        }
      }
    },
    /**
     * Computes form input label value.
     *
     * @param {Object} def Property definition
     * @param {Boolean} required True if the property is required
     * @param {?String} name Property name
     * @return {String} Input display name.
     */
    _computeInputLabel: function(def, required, name) {
      var result = def[SCHEMA + 'name'];
      if (result) {
        result = result[0]['@value'];
      }
      result = result || name || 'Value';
      if (required) {
        result += '*';
      }
      return result;
    },
    /**
     * Computes the value of a property that namespace starts with
     * `http://www.w3.org/ns/shacl`.
     *
     * @param {Object} def Property AMF definition
     * @param {String} property Name of the schema.
     * @return {any|undefined} Value of the property or undefined if not set.
     */
    _computeShaclProperty: function(def, property) {
      var key = SHACL + '#' + property;
      var val = def[key];
      if (val) {
        return val[0]['@value'];
      }
    },
    /**
     * Computes the value of a property that namespace starts with
     * `http://raml.org/vocabularies/shapes`.
     *
     * @param {Object} def Property AMF definition
     * @param {String} property Name of the schema.
     * @return {any|undefined} Value of the property or undefined if not set.
     */
    _computeVocabularyShapeProperty: function(def, property) {
      var key = RAML_V_SHAPES + '#' + property;
      var val = def[key];
      if (val) {
        return val[0]['@value'];
      }
    },
    /**
     * Computes enum values for the view model.
     * @param {[type]} def [description]
     * @return {[type]} [description]
     */
    _computeModelEnum: function(def) {
      var key = SHACL + '#in';
      var val = def[key];
      if (!val) {
        return;
      }
      var result = [];
      return this._computeEnumIterator(val, result);
    },
    /**
     * Computesa value for the `enum` property in the view model.
     * @param {Array} model Current model item for `shacl#in` namespace
     * @param {Array} result Collected values.
     * @return {Array} Final result.
     */
    _computeEnumIterator: function(model, result) {
      if (!model || !model.length) {
        return result;
      }
      model = model[0];
      var firstItem = this._getSchemaSafeValue(model, RDF + '#first');
      if (firstItem) {
        result.push(firstItem);
      }
      var val = model[RDF + '#rest'];
      if (!val) {
        return result;
      }
      return this._computeEnumIterator(val, result);
    },
    /**
     * Gets a value (`@value`) for a property without exceptions.
     *
     * @param {Object} model Model for the value.
     * @param {String} key Model key holding the value
     * @return {any|undefined}
     */
    _getSchemaSafeValue: function(model, key) {
      var root = model[key];
      if (!root) {
        return;
      }
      root = root[0];
      if (!root) {
        return;
      }
      return root['@value'];
    },
    /**
     * Parses example in an array type.
     *
     * @param {String} example An array example
     * @return {Array} Array of examples or string if cannot parse
     */
    __parseArrayExample: function(example) {
      try {
        var arr = JSON.parse(example);
        if (arr instanceof Array) {
          return arr;
        }
        return example;
      } catch (e) {}
      return example;
    },

    /**
     * Computes rendered item input field type based on RAML definition.
     *
     * It will be either numeric or text. Type will be determined from
     * item's type or, in case of array, item's items property.
     *
     * @return {String} Input field type.
     */
    _computeItemInputType: function(item) {
      if (item.type === 'array') {
        if (typeof item.items === 'string') {
          return this.__computeInputType(item.items);
        }
        return this.__computeInputType(item.items.type);
      }
      return this.__computeInputType(item.type);
    },

    __computeInputType: function(type) {
      if (type && NUMBER_INPUT_TYPES.indexOf(type) !== -1) {
        return 'number';
      } else if (type === 'boolean') {
        return 'boolean';
      } else if (type === 'date-only') {
        return 'date';
      }
      return 'text';
    },

    /**
     * Creates a common view model item from a RAML type.
     *
     *
     * @param {Object} item A RAML type definition (property, item, type)
     * @param {Object} opts An options. See `_defaultModelOptions` for definition.
     * @return {Object} A view model. It is a cloned object.
     */
    _createModelObject: function(item, opts) {
      opts = this._defaultModelOptions(opts);
      item = this._clone(item);
      item.isEnum = !!(item.enum && item.enum.length);
      item.isArray = item.type === 'array';
      item.hasDescription = !!item.description;
      item.inputLabel = item.displayName || item.name || 'Value';
      if (item.required) {
        item.inputLabel += '*';
      }
      item.inputType = this._computeItemInputType(item);
      item.isBoolean = item.inputType === 'boolean';

      this._computeModelPattern(item);

      if (item.examples && item.examples.length && item.examples[0]) {
        item.inputPlaceholder = 'Example: ' + item.examples[0];
      } else if (item.example && typeof item.example === 'string') {
        item.inputPlaceholder = 'Example: ' + item.example;
      }
      if (item.inputPlaceholder) {
        item.inputFloatLabel = true;
      }

      if (item.required && typeof item.default !== 'undefined' && !item.value) {
        item.value = item.isArray ? this.__parseArrayExample(item.default) :
          item.default;
      }
      if (typeof item.value === 'undefined' && item.required) {
        if (item.examples) {
          item.value = item.examples[0];
        } else if (item.example) {
          item.value = item.example;
        }
        if (item.value && item.value.indexOf &&
          item.value.indexOf(item.name + opts.valueDelimiter) === 0) {
          item.value = item.value.substr(item.name.length + 1);
        }
        if (typeof item.value === 'undefined' && item.isEnum) {
          item.value = item.enum[0];
        }
      }
      if (opts.decodeValues && item.value && typeof item.value === 'string') {
        item.value = decodeURIComponent(item.value.replace(/\+/g, ' '));
      }

      if (item.value && item.isArray && typeof item.value === 'string') {
        var _v = this.__parseArrayExample(item.value);
        item.value = _v instanceof Array ? _v : [_v];
      }

      if (item.isArray && !item.value) {
        item.value = [''];
      }

      if (item.isBoolean && typeof item.value === 'boolean') {
        item.value = String(item.value);
      }
      return item;
    },
    /**
     * Creates a default options object for model generation.
     *
     * Options:
     * - valueDelimiter a character that glues name and value. '=' for query
     * parameters, ':' for headers and so on. Default to '='
     * - decodeValues, boolean balue, if set, it will decode the value.
     *
     * @param {?Object} opts Passed options
     * @return {Object} Options object with default values if missing.
     */
    _defaultModelOptions: function(opts) {
      opts = opts || {};
      opts.valueDelimiter = opts.valueDelimiter || '=';
      opts.decodeValues = opts.decodeValues || false;
      return opts;
    },
    /**
     * Adds a `pattern` proeprty to the model item if required.
     *
     * @param {Object} item Model item
     * @return {Object} Altered model item
     */
    _computeModelPattern: function(item) {
      if (!item.pattern) {
        if (item.inputType === 'date') {
          item.pattern = '[0-9]{4}-[0-9]{2}-[0-9]{2}';
        }
      }
      return item;
    },

    /**
     * Detects if passed object is an array.
     * @param {any} obj Object to test
     * @return {Boolean} True if passed ibject is an array.
     */
    _isArray: function(obj) {
      return Object.prototype.toString.apply(obj) === '[object Array]';
    },

    /**
     * Deep clones an object.
     * @param {any} obj An object to be cloned.
     * @return {any} Copy of an object.
     */
    _clone: function(obj) {
      var result;
      var i;
      if (typeof obj !== 'object') {
        return obj;
      }
      if (!obj) {
        return obj;
      }
      if (this._isArray(obj)) {
        result = [];
        for (i = 0; i < obj.length; i += 1) {
          result[i] = this._clone(obj[i]);
        }
        return result;
      }
      result = {};
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          result[i] = this._clone(obj[i]);
        }
      }
      return result;
    }
  };
})(window);
</script>
